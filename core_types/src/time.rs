//! The Iso8601 type is defined here. It is used in particular within ChainHeader to enforce that
//! their timestamps are defined in a useful and consistent way.

use chrono::{offset::FixedOffset, DateTime, TimeZone};
use error::HolochainError;
use json::JsonString;
use regex::Regex;
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
use std::{convert::TryFrom, fmt, str::FromStr, time::Duration};

/// Represents a timeout for an HDK function
#[derive(Clone, Deserialize, Debug, Eq, PartialEq, Hash, Serialize, DefaultJson)]
pub struct Timeout(usize);

impl Timeout {
    pub fn new(timeout_ms: usize) -> Self {
        Self(timeout_ms)
    }
}

impl Default for Timeout {
    fn default() -> Timeout {
        Timeout(60000)
    }
}

impl From<Timeout> for Duration {
    fn from(Timeout(millis): Timeout) -> Duration {
        Duration::from_millis(millis as u64)
    }
}

impl From<&Timeout> for Duration {
    fn from(Timeout(millis): &Timeout) -> Duration {
        Duration::from_millis(*millis as u64)
    }
}

impl From<usize> for Timeout {
    fn from(millis: usize) -> Timeout {
        Timeout::new(millis)
    }
}

/// This struct represents datetime data recovered from a string in the ISO 8601 and RFC 3339 (more
/// restrictive) format.  Invalid try_from conversions fails w/ Result<DateTime<FixedOffset>,
/// HolochainError>.
///
/// Iso8601 wraps a DateTime<FixedOffset>, and its Display/Debug formats default to the ISO 8601 /
/// RFC 3339 format, respectively:
///
///    Display: 2018-10-11T03:23:38+00:00
///    Debug:   Iso8601(2018-10-11T03:23:38+00:00)
///
/// More info on the relevant [wikipedia article](https://en.wikipedia.org/wiki/ISO_8601).
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, DefaultJson)]
pub struct Iso8601(DateTime<FixedOffset>);

/// Infallible conversions into and from an Iso8601.  The only infallible way to create an Iso8601
/// is from a Unix timestamp.  An Iso8601 may be converted infallibly to its underlying DateTime<Fixed>

impl From<&Iso8601> for DateTime<FixedOffset> {
    fn from(lhs: &Iso8601) -> DateTime<FixedOffset> {
        lhs.0.to_owned()
    }
}

impl From<Iso8601> for DateTime<FixedOffset> {
    fn from(lhs: Iso8601) -> DateTime<FixedOffset> {
        lhs.0
    }
}

impl From<i64> for Iso8601 {
    fn from(secs: i64) -> Self {
        Self::new(secs, 0)
    }
}

impl Iso8601 {
    fn new(secs: i64, nsecs: u32) -> Self {
        Self(FixedOffset::east(0).timestamp(secs, nsecs))
    }
}

/*
 * Note that the WASM target does not have a reliable and consistent means to obtain the local time,
 * so chrono `now()` methods are unusable: https://github.com/chronotope/chrono/issues/243
 * Therefore, we do not implement a `Iso8601::default()` or `::now()` method at this time.  In
 * addition, supporting internal generated current timestamps is an easy path to non-determinism in
 * holochain Zome functions.  All times should be externally generated, and only *evaluated* by the
 * Zome functions, not generated by them.
 *
 * /// Iso8601::now() and default() return the current Utc time.
 * impl Iso8601 {
 *     pub fn now() -> Iso8601 {
 *         Iso8601::from(Utc::now().to_rfc3339())
 *     }
 * }
 *
 * impl Default for Iso8601 {
 *     fn default() -> Iso8601 {
 *         Iso8601::now()
 *     }
 * }
 */

/// Serialization w/ serde_json to/from String.  This means that a timestamp will be deserialized to
/// an Iso8601 and validated, which may fail, returning a serde::de::Error.  Upon serialization, the
/// canonicalized ISO 8601 / RFC 3339 version of the timestamp will be used.
impl Serialize for Iso8601 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'d> Deserialize<'d> for Iso8601 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'d>,
    {
        let s = String::deserialize(deserializer)?;
        Iso8601::from_str(&s).map_err(|e| de::Error::custom(e.to_string()))
    }
}

/// Outputs the canonicalized ISO 8601 / RFC 3339 form for a valid timestamp.
impl fmt::Display for Iso8601 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0.to_rfc3339())
    }
}

/// Conversions try_from on String/&str on an Iso8601 are fallible conversions, which may produce a
/// HolochainError if the timestamp is not valid ISO 8601 / RFC 3339.  We will allow some
/// flexibilty; strip surrounding whitespace, a bare timestamp missing any timezone specifier will
/// be assumed to be UTC "Zulu", make internal separators optional if unambiguous.  If you keep to
/// straight RFC 3339 timestamps, then parsing will be quick, otherwise we'll employ a regular
/// expression to parse a more flexible subset of the ISO 8601 standard from your supplied
/// timestamp, and then use the RFC 3339 parser again.  We only do this validation once; at the
/// creation of an Iso8601 from a String/&str.
impl TryFrom<String> for Iso8601 {
    type Error = HolochainError;
    fn try_from(s: String) -> Result<Self, Self::Error> {
        Iso8601::from_str(&s)
    }
}

impl TryFrom<&str> for Iso8601 {
    type Error = HolochainError;
    fn try_from(s: &str) -> Result<Self, Self::Error> {
        Iso8601::from_str(s)
    }
}

impl FromStr for Iso8601 {
    type Err = HolochainError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        lazy_static! {
            static ref ISO8601_RE: Regex = Regex::new(
                r"(?x)
                ^
                \s*
                (?P<Y>\d{4})
                (?:            # Always require 4-digit year and double-digit mon/day YYYY[[-]MM[[-]DD]]
                  -?
                  (?P<M>
                     0[1-9]
                   | 1[012]
                  )?
                  (?:
                    -?
                    (?P<D>
                        0[1-9]
                      | [12][0-9]
                      | 3[01]
                    )?
                  )?
                )?
                (?:
                  (?:           # Optional T or space(s)
                    [Tt]
                  | \s+
                  )
                  (?P<h>        # Requires two-digit HH[[:]MM[[:]SS]] w/ consistent optional separators
                    [01][0-9]
                  | 2[0-3]      # but do not support 24:00:00 to designate end-of-day midnight
                  )
                  (?:
                    :?
                    (?P<m>
                      [0-5][0-9]
                    )
                    (?:         # The whole seconds group is optional, implies 00
                      :?
                      (?P<s>
                        (?:
                          [0-5][0-9]
                        | 60    # Support leap-seconds for standards compliance
                        )
                      )
                      (?:
                        [.,]    # Optional subseconds, separated by either ./, (always supply ., below)
                        (?P<ss>
                          \d+
                        )
                      )?
                    )?
                  )?
                )?
                \s*
                (?P<Z>          # no timezone specifier implies Z         
                   [Zz]
                 | (?P<Zsgn>[+-âˆ’]) # Zone sign allows UTF8 minus or ASCII hyphen as per RFC/ISO
                   (?P<Zhrs>\d{2}) # and always double-digit hours offset required
                   (?:             # but if double-digit minutes supplied, colon optional
                     :?
                     (?P<Zmin>\d{2})
                   )?
                )?
                \s*
                $"
            )
            .unwrap();
        }

        Ok(Iso8601(
            DateTime::parse_from_rfc3339(s)
                .or_else(
                    |_| ISO8601_RE.captures(s)
                        .map_or_else(
                            || Err(HolochainError::ErrorGeneric(
                                format!("Failed to find ISO 3339 or RFC 8601 timestamp in {:?}", s))),
                            |cap| {
                                let timestamp = &format!(
                                    "{:0>4}-{:0>2}-{:0>2}T{:0>2}:{:0>2}:{:0>2}{}{}",
                                    &cap["Y"],
                                    cap.name("M").map_or( "1", |m| m.as_str()),
                                    cap.name("D").map_or( "1", |m| m.as_str()),
                                    cap.name("h").map_or( "0", |m| m.as_str()),
                                    cap.name("m").map_or( "0", |m| m.as_str()),
                                    cap.name("s").map_or( "0", |m| m.as_str()),
                                    cap.name("ss").map_or( "".to_string(), |m| format!(".{}", m.as_str())),
                                    cap.name("Z").map_or( "Z".to_string(), |m| match m.as_str() {
                                        "Z"|"z" => "Z".to_string(),
                                        _ => format!(
                                            "{}{}:{}",
                                            match &cap["Zsgn"] { "+" => "+", _ => "-" },
                                            &cap["Zhrs"],
                                            &cap.name("Zmin").map_or( "00", |m| m.as_str()))
                                    }));

                                DateTime::parse_from_rfc3339(timestamp)
                                    .map_err(|_| HolochainError::ErrorGeneric(
                                        format!("Attempting to convert RFC 3339 timestamp {:?} from ISO 8601 {:?} to a DateTime",
                                                timestamp, s)))
                            }
                        )
                )?
        ))
    }
}

// The only infallible conversions are from an i64 UNIX timestamp.  There are no conversions from
// String or &str that are infallible.
//
//     $ date  --date="2018-10-11T03:23:38+00:00" +%s
//     1539228218
//     $ date --date=@1539228218 --rfc-3339=seconds --utc
//     2018-10-11 03:23:38+00:00
//
pub fn test_iso_8601() -> Iso8601 {
    Iso8601::from(1539228218) // 2018-10-11T03:23:38+00:00
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use serde_json;
    use std::convert::TryInto;

    #[test]
    fn test_iso_8601_basic() {
        // Different ways of specifying UTC "Zulu".  A bare timestamp will be defaulted to "Zulu".
        vec![
            "2018-10-11T03:23:38 +00:00",
            "2018-10-11T03:23:38Z",
            "2018-10-11T03:23:38",
            "2018-10-11T03:23:38+00",
            "2018-10-11 03:23:38",
        ]
        .iter()
        .map(|ts| {
            // Check that mapping from an Iso8601::(&str) to a DateTime yields the expected RFC 3339
            // / ISO 8601 timestamp, via its DateTime<FixedOffset>, its fmt::Display, to_string()
            // and JSON round-trip.
            Iso8601::try_from(*ts)
                .and_then(|iso| {
                    assert_eq!(format!("{}", iso), "2018-10-11T03:23:38+00:00");
                    Ok(iso)
                })
                .and_then(|iso| {
                    assert_eq!(
                        format!(
                            "{}",
                            DateTime::<FixedOffset>::from(iso.clone()).to_rfc3339()
                        ),
                        "2018-10-11T03:23:38+00:00"
                    );
                    Ok(iso)
                })
                .and_then(|iso| {
                    assert_eq!(iso.to_string(), "2018-10-11T03:23:38+00:00");
                    Ok(iso)
                })
                .and_then(|iso| {
                    // JSON serialization via serde_json
                    let serialized = serde_json::to_string(&iso)?;
                    assert_eq!(serialized.to_string(), "\"2018-10-11T03:23:38+00:00\"");
                    let deserialized: Iso8601 = serde_json::from_str(&serialized.to_string())?;
                    assert_eq!(deserialized.to_string(), "2018-10-11T03:23:38+00:00");

                    // JSON serialization via JsonSring
                    let iso_8601_ser = JsonString::from(&iso);
                    assert_eq!(iso_8601_ser.to_string(), "\"2018-10-11T03:23:38+00:00\"");
                    let iso_8601_des = Iso8601::try_from(iso_8601_ser);
                    assert!(iso_8601_des.is_ok());
                    assert_eq!(
                        iso_8601_des.unwrap().to_string(),
                        "2018-10-11T03:23:38+00:00"
                    );

                    // JSON round-tripping w/o serde or intermediates
                    assert_eq!(
                        Iso8601::try_from(JsonString::from(iso)),
                        Iso8601::try_from("2018-10-11T03:23:38+00:00")
                    );

                    Ok(())
                })
        })
        .collect::<Result<(()), HolochainError>>()
        .map_err(|e| {
            panic!(
                "Unexpected failure of checked DateTime<FixedOffset> try_from: {:?}",
                e
            )
        })
        .unwrap();

        vec![
            "20180101 0323",
            "2018-01-01 0323",
            "2018 0323",
            "2018-- 0323",
            "2018-01-01 032300",
            "2018-01-01 03:23",
            "2018-01-01 03:23:00",
            "2018-01-01 03:23:00 Z",
            "2018-01-01 03:23:00 +00",
            "2018-01-01 03:23:00 +00:00",
        ]
        .iter()
        .map(|ts| {
            Iso8601::try_from(*ts)
                .and_then(|iso| Ok(assert_eq!(format!("{}", iso), "2018-01-01T03:23:00+00:00")))
        })
        .collect::<Result<(()), HolochainError>>()
        .map_err(|e| {
            panic!(
                "Unexpected failure of checked DateTime<FixedOffset> try_from: {:?}",
                e
            )
        })
        .unwrap();

        // Leap-seconds and sub-second times, in both native RFC 3339 and (Regex-based) ISO 8601.
        // Also exercise the HHMM60 methods for specifying times that extend into the following time
        // period.  Specifically does not support the "24:00:00" times.  Also tests the use of UTF8
        // minus in addition to ASCII hyphen.
        vec![
            "2015-02-18T23:59:60.234567-05:00",
            "2015-02-18T23:59:60.234567âˆ’05:00",
            "2015-02-18 235960.234567 -05",
            "20150218 235960.234567 âˆ’05",
            "20150218 235960,234567 âˆ’05",
        ]
        .iter()
        .map(|ts| {
            let iso_8601 = Iso8601::try_from(*ts)?;
            let dt = DateTime::<FixedOffset>::from(&iso_8601); // from &Iso8601
            Ok(assert_eq!(
                format!("{}", dt.to_rfc3339()),
                "2015-02-18T23:59:60.234567-05:00"
            ))
        })
        .collect::<Result<(()), HolochainError>>()
        .map_err(|e| {
            panic!(
                "Unexpected failure of checked DateTime<FixedOffset> try_from: {:?}",
                e
            )
        })
        .unwrap();

        // Now test a bunch that should fail
        vec![
            "boo",
            "2015-02-18T23:59:60.234567-5",
            "2015-02-18 3:59:60-05",
            "2015-2-18 03:59:60-05",
            "2015-2-18 03:59:60+25",
        ]
        .iter()
        .map(|ts| match Iso8601::try_from(*ts) {
            Ok(iso) => Err(HolochainError::ErrorGeneric(format!(
                "Should not have succeeded in parsing {:?} into {:?}",
                ts, iso
            ))),
            Err(_) => Ok(()),
        })
        .collect::<Result<(()), HolochainError>>()
        .map_err(|e| {
            panic!(
                "Unexpected success of invalid checked DateTime<FixedOffset> try_from: {:?}",
                e
            )
        })
        .unwrap();

        // PartialEq and PartialOrd Comparison operators
        assert!(
            Iso8601::try_from("2018-10-11T03:23:38+00:00").unwrap()
                == Iso8601::try_from("2018-10-11T03:23:38Z").unwrap()
        );
        assert!(
            Iso8601::try_from("2018-10-11T03:23:38").unwrap()
                == Iso8601::try_from("2018-10-11T03:23:38Z").unwrap()
        );
        assert!(
            Iso8601::try_from(" 20181011  0323  Z ").unwrap()
                == Iso8601::try_from("2018-10-11T03:23:00Z").unwrap()
        );

        // Fixed-offset ISO 8601 are comparable to UTC times
        assert!(
            Iso8601::try_from("2018-10-11T03:23:38-08:00").unwrap()
                == Iso8601::try_from("2018-10-11T11:23:38Z").unwrap()
        );
        assert!(
            Iso8601::try_from("2018-10-11T03:23:39-08:00").unwrap()
                > Iso8601::try_from("2018-10-11T11:23:38Z").unwrap()
        );
        assert!(
            Iso8601::try_from("2018-10-11T03:23:37-08:00").unwrap()
                < Iso8601::try_from("2018-10-11T11:23:38Z").unwrap()
        );

        match Iso8601::try_from("boo") {
            Ok(iso) => panic!(
                "Unexpected success of checked DateTime<FixedOffset> try_from: {:?}",
                iso
            ),
            Err(e) => assert_eq!(
                format!("{}", e),
                "Failed to find ISO 3339 or RFC 8601 timestamp in \"boo\""
            ),
        }
    }

    #[test]
    fn test_iso_8601_sorting() {
        // Different ways of specifying UTC "Zulu".  A bare timestamp will be defaulted to "Zulu".
        let mut v: Vec<Iso8601> = vec![
            "2018-10-11T03:23:39-08:00".try_into().unwrap(),
            "2018-10-11T03:23:39-07:00".try_into().unwrap(),
            "2018-10-11 03:23:39+03:00".try_into().unwrap(),
            "2018-10-11T03:23:39-06:00".try_into().unwrap(),
            "20181011 032339 +04:00".try_into().unwrap(),
            "2018-10-11T03:23:39âˆ’09:00".try_into().unwrap(), // note the UTF8 minus instead of ASCII hyphen
            "2018-10-11T03:23:39+11:00".try_into().unwrap(),
            "2018-10-11 03:23:39Z".try_into().unwrap(),
            "2018-10-11 03:23:40".try_into().unwrap(),
        ];
        v.sort_by(|a, b| {
            let cmp = a.cmp(b);
            //println!( "{} {:?} {}", a, cmp, b );
            cmp
        });
        assert_eq!(
            v.iter()
                .map(|ts| format!("{:?}", &ts).to_string())
                .collect::<Vec<String>>()
                .join(", "),
            concat!(
                "Iso8601(2018-10-11T03:23:39+11:00), ",
                "Iso8601(2018-10-11T03:23:39+04:00), ",
                "Iso8601(2018-10-11T03:23:39+03:00), ",
                "Iso8601(2018-10-11T03:23:39+00:00), ",
                "Iso8601(2018-10-11T03:23:40+00:00), ",
                "Iso8601(2018-10-11T03:23:39-06:00), ",
                "Iso8601(2018-10-11T03:23:39-07:00), ",
                "Iso8601(2018-10-11T03:23:39-08:00), ",
                "Iso8601(2018-10-11T03:23:39-09:00)"
            )
        );

        v.sort_by(|a, b| b.cmp(a)); // reverse
        assert_eq!(
            v.iter()
                .map(|ts| format!("{:?}", &ts).to_string())
                .collect::<Vec<String>>()
                .join(", "),
            concat!(
                "Iso8601(2018-10-11T03:23:39-09:00), ",
                "Iso8601(2018-10-11T03:23:39-08:00), ",
                "Iso8601(2018-10-11T03:23:39-07:00), ",
                "Iso8601(2018-10-11T03:23:39-06:00), ",
                "Iso8601(2018-10-11T03:23:40+00:00), ",
                "Iso8601(2018-10-11T03:23:39+00:00), ",
                "Iso8601(2018-10-11T03:23:39+03:00), ",
                "Iso8601(2018-10-11T03:23:39+04:00), ",
                "Iso8601(2018-10-11T03:23:39+11:00)"
            )
        );
    }
}
